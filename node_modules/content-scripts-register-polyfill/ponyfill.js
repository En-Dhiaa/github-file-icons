import { executeFunction, executeScript, insertCSS } from 'webext-content-scripts';
import chromeP from 'webext-polyfill-kinda';
import { patternToRegex } from 'webext-patterns';
const gotNavigation = typeof chrome === 'object' && 'webNavigation' in chrome;
async function isOriginPermitted(url) {
    return chromeP.permissions.contains({
        origins: [new URL(url).origin + '/*'],
    });
}
async function wasPreviouslyLoaded(target, assets) {
    // Checks and sets a global variable
    const loadCheck = (key) => {
        // @ts-expect-error "No index signature"
        const wasLoaded = document[key];
        // @ts-expect-error "No index signature"
        document[key] = true;
        return wasLoaded;
    };
    // The assets object is used as a key on `document`
    return executeFunction(target, loadCheck, JSON.stringify(assets));
}
// The callback is only used by webextension-polyfill
export default async function registerContentScript(contentScriptOptions, callback) {
    const { js = [], css = [], matchAboutBlank, matches, excludeMatches, runAt, } = contentScriptOptions;
    let { allFrames } = contentScriptOptions;
    if (gotNavigation) {
        allFrames = false;
    }
    else if (allFrames) {
        console.warn('`allFrames: true` requires the `webNavigation` permission to work correctly: https://github.com/fregante/content-scripts-register-polyfill#permissions');
    }
    const matchesRegex = patternToRegex(...matches);
    const excludeMatchesRegex = patternToRegex(...excludeMatches !== null && excludeMatches !== void 0 ? excludeMatches : []);
    const inject = async (url, tabId, frameId = 0) => {
        if (!matchesRegex.test(url) // Manual `matches` glob matching
            || excludeMatchesRegex.test(url) // Manual `exclude_matches` glob matching
            || !await isOriginPermitted(url) // Without this, we might have temporary access via accessTab
            || await wasPreviouslyLoaded({ tabId, frameId }, { js, css }) // Avoid double-injection
        ) {
            return;
        }
        insertCSS({
            tabId,
            frameId,
            files: css,
            matchAboutBlank,
            runAt,
        });
        await executeScript({
            tabId,
            frameId,
            files: js,
            matchAboutBlank,
            runAt,
        });
    };
    const tabListener = async (tabId, { status }, { url }) => {
        // Only status updates are relevant
        // No URL = no permission
        if (status && url) {
            void inject(url, tabId);
        }
    };
    const navListener = async ({ tabId, frameId, url, }) => {
        void inject(url, tabId, frameId);
    };
    if (gotNavigation) {
        chrome.webNavigation.onCommitted.addListener(navListener);
    }
    else {
        chrome.tabs.onUpdated.addListener(tabListener);
    }
    const registeredContentScript = {
        async unregister() {
            if (gotNavigation) {
                chrome.webNavigation.onCommitted.removeListener(navListener);
            }
            else {
                chrome.tabs.onUpdated.removeListener(tabListener);
            }
        },
    };
    if (typeof callback === 'function') {
        callback(registeredContentScript);
    }
    return registeredContentScript;
}
