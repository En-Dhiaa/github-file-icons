import chromeP from 'webext-polyfill-kinda';
const gotScripting = typeof chrome === 'object' && 'scripting' in chrome;
function castTarget(target) {
    return typeof target === 'object' ? target : {
        tabId: target,
        frameId: 0,
    };
}
function castArray(possibleArray) {
    if (Array.isArray(possibleArray)) {
        return possibleArray;
    }
    return [possibleArray];
}
export async function executeFunction(target, function_, ...args) {
    const { frameId, tabId } = castTarget(target);
    if (gotScripting) {
        const [injection] = await chrome.scripting.executeScript({
            target: {
                tabId,
                frameIds: [frameId],
            },
            func: function_,
            args,
        });
        return injection === null || injection === void 0 ? void 0 : injection.result;
    }
    const [result] = await chromeP.tabs.executeScript(tabId, {
        code: `(${function_.toString()})(...${JSON.stringify(args)})`,
        frameId,
    });
    return result;
}
function arrayOrUndefined(value) {
    return typeof value === 'undefined' ? undefined : [value];
}
// eslint-disable-next-line @typescript-eslint/naming-convention -- It follows the native naming
export function insertCSS({ tabId, frameId, files, allFrames, matchAboutBlank, runAt, }) {
    for (let content of files) {
        if (typeof content === 'string') {
            content = { file: content };
        }
        if (gotScripting) {
            void chrome.scripting.insertCSS({
                target: {
                    tabId,
                    frameIds: arrayOrUndefined(frameId),
                    allFrames,
                },
                files: 'file' in content ? [content.file] : undefined,
                css: 'code' in content ? content.code : undefined,
            });
        }
        else {
            void chromeP.tabs.insertCSS(tabId, {
                ...content,
                matchAboutBlank,
                allFrames,
                frameId,
                runAt: runAt !== null && runAt !== void 0 ? runAt : 'document_start', // CSS should prefer `document_start` when unspecified
            });
        }
    }
}
export async function executeScript({ tabId, frameId, files, allFrames, matchAboutBlank, runAt, }) {
    let lastInjection;
    for (let content of files) {
        if (typeof content === 'string') {
            content = { file: content };
        }
        if (gotScripting) {
            if ('code' in content) {
                throw new Error('chrome.scripting does not support injecting strings of `code`');
            }
            void chrome.scripting.executeScript({
                target: {
                    tabId,
                    frameIds: arrayOrUndefined(frameId),
                    allFrames,
                },
                files: [content.file],
            });
        }
        else {
            // Files are executed in order, but code isnâ€™t, so it must wait the last script #31
            if ('code' in content) {
                // eslint-disable-next-line no-await-in-loop -- On purpose, to serialize injection
                await lastInjection;
            }
            lastInjection = chromeP.tabs.executeScript(tabId, {
                ...content,
                matchAboutBlank,
                allFrames,
                frameId,
                runAt,
            });
        }
    }
}
export async function injectContentScript(target, scripts) {
    var _a, _b, _c, _d, _e, _f;
    const { frameId, tabId } = typeof target === 'object' ? target : {
        tabId: target,
        frameId: 0,
    };
    const injections = [];
    for (const script of castArray(scripts)) {
        insertCSS({
            tabId,
            frameId,
            files: (_a = script.css) !== null && _a !== void 0 ? _a : [],
            matchAboutBlank: (_b = script.matchAboutBlank) !== null && _b !== void 0 ? _b : script.match_about_blank,
            runAt: (_c = script.runAt) !== null && _c !== void 0 ? _c : script.run_at,
        });
        // It's ok if the order of scripts is not guaranteed between different blocks
        void executeScript({
            tabId,
            frameId,
            files: (_d = script.js) !== null && _d !== void 0 ? _d : [],
            matchAboutBlank: (_e = script.matchAboutBlank) !== null && _e !== void 0 ? _e : script.match_about_blank,
            runAt: (_f = script.runAt) !== null && _f !== void 0 ? _f : script.run_at,
        });
    }
    await Promise.all(injections);
}
